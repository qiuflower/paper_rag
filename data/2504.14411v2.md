## **Planet as a Brain: Towards Internet of AgentSites** **based on AIOS Server**

**Xiang Zhang** *[†∗]* **Yongfeng Zhang** *[‡∗]*

*†* Boston University *‡* Rutgers University *∗* AIOS Foundation
xz0224@bu.edu yongfeng.zhang@rutgers.edu
### **Abstract**

The internet is undergoing a historical transformation from the “Internet of Websites” to the “Internet of AgentSites.” While traditional Websites served as the
foundation for information hosting and dissemination, a new frontier is emerging
where AgentSites serve as the hubs of the internet, where each AgentSite hosts
one or more AI agents that receive tasks, address them, and deliver actionable solutions, marking a significant shift in the digital landscape and representing the next
generation of online ecosystems. Under this vision, AIOS, the AI Agent Operating
System, serves as the server for the development, deployment and execution of AI
agents, which is a fundamental infrastructure for the Internet of Agentsites.

In this paper, we introduce AIOS Server, a runtime framework designed to host
agents and support large-scale collaboration among decentralized agents. AIOS
Server provides a standardized communication protocol leveraging the Model
Context Protocol (MCP) and JSON-RPC to enable structured agent-agent or humanagent interactions. Each AIOS node operates as an independent server, capable of
hosting and executing agents, while supporting peer-to-peer coordination without
reliance on centralized orchestration.

Based on AIOS Server, we further present the world’s first practically deployed
Internet of Agentsites (AIOS-IoA), including AgentHub for agent registration
and management as well as AgentChat for interactive communication, at `https:`
`//planet.aios.foundation` . Furthermore, we prototype an agent discovery
mechanism based on Distributed Hash Tables (DHT) and a Gossip protocol, which
serves as the search engine for the internet of agentsites, enabling scalable and
resilient agent registry and lookup on this new internet.

Our evaluation demonstrates that AIOS Server achieves low-latency communication, efficient task delegation, and robust coordination in agent networks. This
work provides a practical foundation for building the Internet of Agentsites —
a new paradigm where autonomous agents become first-class citizens of the
web. The implementation is available at `https://github.com/agiresearch/`
`AIOS.Server` and will be integrated into the AIOS main branch at `https:`
`//github.com/agiresearch/AIOS` .
### **1 Introduction**

The rapid progress of large language models (LLMs) has led to the emergence of autonomous
agents capable of planning, reasoning, and interacting with humans and other agents in structured
environments [ 17, 22, 21, 18 ]. These agents increasingly act beyond static response generation,
demonstrating memory, tool usage, and long-term task execution abilities. However, most existing
agent-based systems remain confined within centralized platforms, limiting openness, interoperability,
and scalability in multi-agent ecosystems.

*†* Department of Computer Science, Metropolitan College, Boston University, Boston, MA 02215.


-----

To address these limitations, this paper introduces AIOS Server — a runtime framework designed
to host autonomous agents and facilitate large-scale agent communication across the internet. Each
AIOS server hosts one or more autonomous AI agents, constituting an Agentsite — just like the
way that Nginx server hosts Websites. Agentsites are further connected through the internet for
human-agent and agent-agent communication, establishing the Internet of Agentsites, akin to the
Internet of Websites that constitute the world wide web (WWW).

AIOS Server provides a standardized communication protocol combining the MCP (Model Context
Protocol) and JSON-RPC (JavaScript Object Notation - Remote Procedure Call), enabling structured
interactions between agents, humans, and external services. Each AIOS Server node operates
as an independent execution environment, supporting dynamic agent deployment, peer-to-peer
communication, and decentralized coordination without relying on centralized control.

Building on the AIOS Server, we further present the world’s first practically deployed Internet of
Agentsites (AIOS-IoA) — an open ecosystem where distributed agents, hosted across heterogeneous
sites (AgentSites), interact and collaborate at internet scale. The AIOS-IoA architecture includes
AgentHub for agent registration and management, and AgentChat for interactive human-agent
communication, both available at `https://planet.aios.foundation` .

To enable scalable and resilient agent discovery across this decentralized network, we design and
prototype an agent search mechanism based on Distributed Hash Tables (DHT) and a Gossip protocol.
This decentralized search engine provides efficient registry, lookup, and discovery functionalities,
allowing agents to interact across distributed environments in a robust and fault-tolerant manner.

In summary, our key contributions are:

- We propose AIOS Server, a decentralized runtime framework enabling structured communication
and coordination among autonomous agents.

- We implement the Internet of Agentsites (AIOS-IoA), providing the first practical deployment of
an open, agent-centric web ecosystem.

- We design and evaluate a DHT-based decentralized agent registration and discovery mechanism,
supporting scalable search and registry across agent networks.

- We empirically evaluate AIOS Server in real-world deployment settings, demonstrating low-latency
communication, efficient task delegation, and robust peer-to-peer coordination.

This work builds on recent advances in agent system
infrastructures [ 12, 7, 4 ], memory-enhanced LLM
agents [ 21, 18 ], and agent communication protocols

[ 1, 5, 11 ]. AIOS Server emphasizes modularity, interoperability, and robustness as foundational elements for open and scalable agent ecosystems. This
work contributes a practical foundation for building
the next-generation Internet of Agentsites, where autonomous agents operate as first-class citizens of the
web, capable of decentralized collaboration, search,
and interaction.

Recent works such as [ 3 ] explored the idea of the internet of agents as a multi-agent framework in terms
of agent team up and collaboration. However, our
work is different in that we do not focus on agent Figure 1: Global view showing agentsites deteam up and collaboration, but on the physical, decen- ployed in London, Singapore, and Tokyo.
tralized and real-world deployment of agents across
the globe (as shown in Figure 1), just like the physical Internet of Websites, where each website
runs on a server at a certain location on the planet, and servers are connected through the internet to
constitute the world wide web (WWW). As a result, our infrastructure is denoted as the Internet of
Agentsites for differentiation and for highlighting the analogy with the Internet of Websites.

2


-----

### **2 Related Work and Background**

**2.1** **LLM-Powered Agent Systems**

Recent advances in large language models (LLMs) have enabled the creation of autonomous agents
that can interpret tasks, use tools, and maintain state over long interactions [ 17, 22, 25, 23 ]. These
agents are no longer limited to single-turn responses—they can reason, remember, and act in structured
workflows [ 21, 18 ]. Frameworks such as Camel [ 9 ], OpenAGI [ 6 ], AIOS [ 12 ], AutoGen [ 19 ]
and MetaGPT [ 7 ] define agent execution workflows and pipelines, where agents assume roles to
work on task decomposition and decision-making either individually or collaboratively. Memoryaugmented systems, including A-Mem and Workflow Memory [ 21, 18 ], provide persistent state
tracking, improving contextual understanding and coherence. LLM-based agents now actively
support applications in software development [ 15 ], web interaction [ 8, 4 ], and interactive simulations

[16], extending their practical utility across domains.

**2.2** **Agent Communication and Protocol Design**

Effective coordination in agent systems requires clear, interpretable communication. Structured
interaction protocols—such as ReAct [ 22 ] and intent-based dialogue models—enable agents to
plan, reason, and act based on conversational or environmental context. Recent works explore
debate and discussion as communication primitives to improve factuality and reasoning depth

[ 5, 11, 3, 14, 19 ]. Message-oriented protocols like JSON-RPC are widely adopted to support
structured, machine-readable interaction between agent components or subsystems. Emerging
platforms such as AgentVerse [ 2 ], OS-Copilot [ 20 ], and Formal-LLM [ 10 ] emphasize modular
communication layers, enabling agents to interact with tools, APIs, and other services in well-defined
formats.

**2.3** **Infrastructure and Decentralized Execution**

Traditional AI agents often depend on centralized backends for registration, execution, and orchestration. This architecture limits scalability, introduces single points of failure, and reduces system
adaptability. Recent efforts propose decentralized execution environments that distribute agent hosting and discovery across independent nodes. Platforms like AIOS (AI Agent Operating System)

[ 12 ] highlight the need for developer-friendly, general-purpose agent development, hosting and
execution frameworks. Our system builds on this foundation by introducing a runtime that integrates
agent communication, registration, and discovery into a fully distributed infrastructure. Security
and evaluation remain key concerns. Benchmarking frameworks such as ASB [ 24 ] and GAIA [ 13 ]
provide standardized settings for assessing agent robustness, safety, and coordination capabilities at
scale.
### **3 Overview of System Architecture**

AIOS Server operates as a layered architecture that facilitates communication between human users
and autonomous agents. Figure 2 illustrates the overall architecture of the AIOS server system.

Each AIOS server node operates independently, hosting agents and managing tasks. Core components
include an agent manager, system monitor, task processor, and node client. AIOS server nodes interact
with an agent registry node for agent registration, discovery, task assignment, and health monitoring.
The registry node maintains the metadata of AIOS server nodes and provides an interface for users
to interact and delegate tasks to the agents on various AIOS servers. This node registration design
enhances the safety and security of the Internet of Agentsites since malicious agents can be discovered
at the registry node to prevent harms to the network. Note that there can be more than one registry
nodes in the network and each AIOS server node can decide which registry node(s) to register itself.
Furthermore, a web-based monitoring interface at the registry provides real-time visibility into node
performance, geographic distribution, and system metrics.

In the following sections, we will introduce the agent communication, registration, discovery, and
execution protocols step by step.
### **4 AIOS Communication Protocol**

We start by designing the AIOS Communication Protocol, which facilitates structured interactions in
agent-based systems, encompassing *(i)* Human-Agent Communication Protocol and *(ii)* Agent-Agent
Communication Protocol. To ensure interoperability and scalability, we implement based on the

3


-----

Figure 2: AIOS Server architecture with layers for messaging, agents, and services.

Model Context Protocol (MCP) v1.2.1 [1], a standardized framework for integrating Large Language
Models (LLMs) with external tools and data sources.

MCP follows a client-server architecture, where structured requests and responses enable seamless
AI-driven workflows. LLMs often require access to external computation, structured data, and APIs
to improve reasoning and task execution. Traditional integrations rely on *ad hoc* solutions, limiting
scalability and security. MCP addresses these limitations by providing:

- *Interoperability* : A standardized interface compatible with multiple LLM providers;

- *Modular architecture* : Decoupled deployment of models, tools, and data sources;

- *Secure data handling* : Controlled access aligned with infrastructure constraints.

We present an MCP v1.2.1 implementation for agent-agent and human-agent communication, using
JSON-RPC for structured request-response exchanges. We explore its role in AI workflow orchestration, inter-agent collaboration, and scalable task delegation within the AIOS-IoA framework.

**4.1** **Human-Agent Communication Protocol**

The Human-Agent Communication Protocol enables structured interaction between humans and AI
agents, where human users can issue tasks, request information, and receive structured responses. The
agents running on AIOS server operate as intelligent assistants that interpret user requests, perform
computations, and return results in a standardized format.

The MCP-based communication workflow follows a structured protocol to ensure efficient and
scalable interactions. The process consists of four key steps:

1. *Task Initialization* : A structured JSON-RPC request is issued to an MCP-compliant agent.

2. *Processing* : The agent interprets the request and executes the assigned task.

3. *Response Generation* : The agent returns a structured response.

4. *Iterative Refinement (Optional)* : The requester may refine the query, triggering further interactions.

Figure 3 shows how human users interact with agents through standardized workflow. Requests are
submitted as structured prompts and agents return contextual responses via the MCP protocol. The
communication workflow possesses the following key features: 1) *Standardized Message Format*,
which ensures structured, machine-readable exchanges; 2) *Context-Aware Execution*, where agents
process requests with system and conversational context awareness; 3) *Multi-Turn Capability*, which
supports iterative refinements and follow-up queries; 4) *Progress and Error Handling*, which enables
structured status tracking and exception management. For better illustration, we provide examples of
user request in Appendix A.2, and examples of AI agent response in Appendix A.4.

1 `https://modelcontextprotocol.io/introduction`

4


-----

Figure 3: Human-Agent Protocol: Users communicate with AI agents using structured requests.

Figure 4: Agent-Agent Protocol: Structured messaging between autonomous agents.

**4.2** **Agent-Agent Communication Protocol**

The Agent-Agent Communication Protocol facilitates interactions between AI agents in a decentralized, distributed computing environment. Agents communicate dynamically to delegate tasks, share
data, and execute workflows collaboratively. The communication workflow consists of four key steps:

1. *Agent Discovery* : Agents dynamically identify peers via a distributed registry.

2. *Task Delegation* : An agent delegates a task to another capable agent.

3. *Task Execution* : The receiving agent processes the task.

4. *Response Handling* : The requesting agent integrates the results into its workflow.

Figure 4 illustrates the agent-to-agent communication process. Agents exchange structured messages
using JSON-RPC to delegate and coordinate tasks. The protocol enables multi-stage workflows
across distributed nodes. The communication workflow possesses the following key features: 1)
*Decentralized Agent Lookup*, which is realized through dynamic agent discovery via distributed
registries; 2) *Intent-Based Messaging*, where agents can specify their roles (query, delegate, collaborate) when sending messages through the internet; 3) *Hierarchical Task Execution*, which enables
multi-step workflows across agents; 4) *Message Routing*, which is naturally supported by IP-based
message routing and delivery through the internet. Similarly, examples of task delegation request are
provided in Appendix B.2, and examples of agent response are provided in Appendix B.4.

**4.3** **Human-Agent vs. Agent-Agent Communication**

For better understanding of the similarity and difference between the human-agent and agent-agent
communication protocols, we summarize the key features of the two protocols in Table 1.

**4.4** **Communication Examples**

Figure 5 and Figure 6 illustrate the primary communication modes in the AIOS server system:
agent-agent communication and human-agent communication.

5


-----

|Feature|Human-Agent Communication|Agent-Agent Communication|
|---|---|---|
|Initiator|Human user|AI agent|
|Message Flow|Request →Response|Request →Task Delegation →Response|
|Interaction Type|Direct command execution|Autonomous collaboration|
|Capabilities|Single-task execution|Multi-task delegation|
|Routing|Direct|Dynamic peer-to-peer|
|Use Case|AI assistants, task execution|Distributed AI, multi-agent workflows|


Table 1: Comparison of human-agent and agent-agent communication protocols

Figure 5 depicts the agent-to-agent messaging workflow. The initiating agent constructs a request
via the Request Builder and sends it through a protocol layer that supports RPC or WebSocket. The
message is authenticated and encrypted before being routed to the target agent. The receiving agent
processes the request and returns a structured response via the same secure channel.

In contrast, Figure 6 presents the human-agent interaction pipeline. Human users can interact through
multiple interfaces (API, CLI, or Web UI). The protocol layer formats, validates and enriches the
message with context before passing it to the agent layer, where internal tools or LLMs execute the
task. Responses are formatted and routed back through the same protocol layer.

These interaction flows demonstrate the modularity and interoperability of the AIOS server communication protocols, supporting machine-to-machine coordination and user-facing automation.
### **5 Node Registration and Discovery**

Scalable agent communication requires effective methods for agent discovery and management. AIOS
server addresses this challenge by implementing a decentralized agent registration and discovery
mechanism, ensuring a safe, fault-tolerant, and adaptive agent ecosystem.

Besides nodes that host agents, there are one or more agent registry nodes in the network. When
an agent node is launched, it needs to register itself on one or more registry nodes, so that it can
be discovered and receive tasks in the network. After registration, each agent node periodically
advertises its availability using a structured metadata which includes the following fields:

- `"agent_id"` : Unique identifier of the agent, typically in the format `namespace/agent_name` .

- `"description"` : List of functional tags or capabilities offered by the agent.

- `"last_seen"` : Timestamp (in UTC) indicating the most recent broadcast from the agent.



6


-----

This decentralized agent registration and discovery mechanism eliminates reliance on a single
registration service and improves system resilience, meanwhile enhance the safety of the network
since agent information can be found on one or more registry nodes to prevent malicious agents in
the network. We provide the design and implementation details of the mechanism in the following.

**5.1** **AIOS Server as an Autonomous Node**

AIOS Server functions as independent, self-regulating entities capable of dynamic task delegation
and workload distribution. Each server node serves a dual role: it acts as both a *service provider*
by hosting agents and a *dynamic client* by accessing external services. Each node supports: *Service*
*Hosting* : AIOS server node exposes API endpoints for agent-based task execution, and *Remote*
*Invocation* : Nodes delegate tasks to other AIOS agents when needed. This structure allows for
adaptive workload balancing and efficient inter-node communication.

When a node receives a task request, it follows the following *Agent Execution Workflow* :

1. *Local Execution* : The task is executed locally if a suitable agent is available.

2. *Task Delegation* : If no local agent is available, the task is delegated to another AIOS server node
via an *adaptive routing* mechanism.

3. *Task Completion* : The designated agent processes the request and returns the result.

4. *Result Integration* : The originating node receives and integrates the response.

Each node periodically reports its state and active agents. Examples for the structure of AIOS node
status report is shown in Appendix C.1, and the structure of AIOS node task assignment is shown in
Appendix C.2.

The AIOS autonomous node architecture provides several benefits: 1) *Scalability* : Nodes operate
independently, enabling seamless system expansion; 2) *Fault Tolerance* : Failure of a single node does
not impact system functionality; 3) *Load Balancing* : Tasks are dynamically allocated based on node
capacity; 4) *Decentralized Execution* : AIOS nodes reduce reliance on static configurations.

**5.2** **Decentralized Registration with Distributed Hash Table and Gossip Protocol**

We design and implement a decentralized registration system to support scalable, fault-tolerant
agent discovery in the ecosystem. This system integrates a Distributed Hash Table (DHT) and a
Gossip-based synchronization protocol, enabling AIOS agents to register, discover, and monitor each
other across a peer-to-peer (P2P) network without relying on centralized services.

7


-----

Figure 7: Decentralized agent discovery and metadata propagation pipeline. The system operates
in four stages: (1) agents are launched with local agent nodes; (2) metadata is stored and replicated
across neighboring nodes via DHT; (3) presence and state changes are propagated using the Gossip
protocol; (4) other agent nodes synchronize state and notify agents of network updates.

The prototype architecture integrates two core components to support decentralized agent registration
and synchronization:

- *Kademlia-based Distributed Hash Table (DHT)* : Provides structured, key-based metadata storage
and lookup with logarithmic complexity *O* (log *n* ) across *n* nodes.

- *Gossip-based Synchronization Protocol* : Enables periodic, peer-to-peer propagation of agent
presence and status updates with eventual consistency guarantees.

These components are exposed to the AIOS server runtime through an abstraction layer, allowing
seamless integration with higher-level agent workflows. This design separates protocol logic from
task execution, enabling modular deployment and interoperability.

Figure 7 presents the end-to-end metadata flow in the decentralized system, highlighting the hybrid
interplay between DHT-based storage and Gossip-driven state dissemination. Note that although
there are different types of nodes in the system, all of the nodes are basically running the same AIOS
server code base, they are just taking different roles by activating different functionalities in the sever.
The architecture avoids centralized coordination while ensuring scalability, fault tolerance, and high
metadata availability under dynamic network conditions.

The overall process unfolds through four stages:

1. *Agent Launch* : Agents are launched on local AIOS server node and publish their capability
metadata to the node.

2. *Agent Registration on DHT Storage* : The DHT nodes store and replicate metadata across the DHT
overlay for fault-tolerant lookup.

3. *Gossip Dissemination* : Gossip nodes periodically exchange presence and status deltas with a
random subset of peers.

4. *State Synchronization* : Other agent nodes apply received updates and notify their agents of
topology or role changes.

This decentralized design enables robust, scalable agent discovery and coordination. It remains
resilient to node churn and transient failures, offering a practical foundation for distributed, multiagent collaboration in real-world deployment environments. Detailed implementation logic and
source code examples are provided in Appendix D.

8


-----

|Feature|Centralized AIOS|Decentralized AIOS|
|---|---|---|
|Agent Registration|Managed by a central server|Distributed across AIOS nodes|
|Fault Tolerance|Single point of failure|Resilient via peer-to-peer network|
|Scalability|Limited by central server capacity|Horizontally scalable|
|Task Delegation|Static assignment|Dynamic inter-node routing|
|Message Routing|Centralized relay|Multi-hop decentralized routing|
|Example Use Case|Small-scale AI automation|Large-scale distributed AI collaboration|


Table 2: Comparison of Centralized and Decentralized AIOS Architectures

**5.3** **Functional Capabilities and Design Trade-offs**

In summary, the decentralized registration system supports the following key functions: 1) *Agent*
*Registration and Lookup* : Agents publish their identity and capability metadata to the DHT using
globally unique keys. Peers can efficiently retrieve these records to locate suitable collaborators; 2)
*Dynamic Node Management* : New nodes can join the system anytime, synchronize routing tables, and
begin participating in the registration network with minimal configuration; 3) *Fault-Tolerant Metadata*
*Replication* : The system replicates agent records across multiple DHT nodes to maintain availability
during node failures or temporary disconnections; 4) *Real-Time Presence Dissemination* : Using the
Gossip protocol, AIOS nodes periodically exchange state information to track agent liveness and
capability updates in near real-time.

This design enables several important advantages of the system: 1) *High Availability* : No single point
of failure—nodes can join or leave without disrupting global service; 2) *Scalability* : Performance
scales logarithmically with network size due to the DHT structure; 3) *Self-Organization* : Nodes
form an adaptive topology, requiring no centralized coordination; 4) *Resilient Status Tracking* :
Gossip-based synchronization ensures soft-state convergence even under unreliable connectivity.

**5.4** **Distributed Agent Hub**

Figure 8 illustrates the architecture of the distributed AgentHub system. Each AIOS agent node
maintains a set of local agents and a local cache, reporting its status to the central registry nodes.
The central registry nodes manage a global view of agent availability through a registry database
and monitors node health using a dedicated checker. A synchronization manager propagates updates
across the network, ensuring consistency between nodes. This design supports decentralized agent
discovery, fault-tolerant registration, and real-time coordination across geographically distributed
nodes. Table 2 shows a comparison between the centralized client-server mode and the decentralized
internet of agentsite mode of AIOS.
### **6 Experiments**

We evaluate the AIOS server communication framework under local and cloud-based deployments.
Experiments assess three core metrics: latency, throughput, and agent registration efficiency in a
decentralized setting.

**6.1** **Experimental Setup**

All tests were performed using structured JSON-RPC requests under controlled concurrency levels.
Two environments were evaluated:

- **Local** : Simulated on a macOS machine (Apple M-series CPU) running multiple AIOS nodes.

- **Cloud** : Deployed to a public endpoint at `https://planet.aios.foundation` .

Each test involved 50, 100, and 200 total requests issued through 5, 10, and 20 concurrent users,
respectively.

**6.2** **Communication Performance Results**

AIOS server achieved 100% response success in all scenarios. Latency scaled predictably with load,
while throughput increased steadily. The system demonstrated reliable performance in both local and
cloud environments. Despite infrastructure differences, latency remained under 200ms in all cases.
Throughput increased with load, reaching up to 229 requests per second in the cloud deployment.
This confirms the framework’s scalability and consistency across platforms.

9


-----

|Environment|Load|Avg. Latency (s)|Throughput (req/s)|
|---|---|---|---|
|Local Local Local|50 reqs 100 reqs 200 reqs|0.061 0.104 0.165|80.2 116.9 163.1|
|Cloud Cloud Cloud|50 reqs 100 reqs 200 reqs|0.143 0.145 0.145|32.2 100.0 229.3|


Table 3: AIOS server communication performance under local and cloud deployments

**6.3** **Node Discovery Performance**

The agent discovery protocol was tested using distributed AIOS nodes and evaluated based on
registration latency. Across 3, 5, and 7 nodes, all agents successfully registered within milliseconds.
Average registration time remained consistent at 1ms, with a maximum delay of 2ms. These results
confirm the efficiency and stability of the DHT and gossip-based synchronization mechanism. Overall,
the AIOS server protocol demonstrates low-latency, high-throughput communication and rapid agent
registration across diverse environments. These findings confirm its robustness for decentralized
agent communication.

**6.4** **System Visualization and Demonstration**

This section presents interface-level illustrations of the AIOS server infrastructure. These visuals
support the system’s functional claims, highlighting its distributed design, agent orchestration, and
human-agent interaction.

10


-----

**6.4.1** **Global Node Distribution**

Figures 9a and 9b display the global distribution of active AIOS nodes. Each point represents an
autonomous server instance hosting LLM agents. These nodes are geographically dispersed and form
a decentralized agent network.


(a) Pacific view showing active nodes in San Francisco.


(b) Eurasian view showing nodes in London, Singapore, and Tokyo.


Figure 9: Global nodes map showing nodes at different locations across the Internet of Agentsites.

**6.4.2** **Node Overview Interface**

Figure 10 provides a snapshot of the AIOS node dashboard. Each node card shows its current resource
usage, platform type, and available agents. All nodes are synchronized and support real-time task
execution.

Figure 10: Distributed node dashboard showing CPU/memory usage, platform type, agent availability.

**6.4.3** **Node Detail and Interaction Interface**

Figure 11 presents the detailed view of an individual AIOS node. Users can inspect system performance, choose specific agents, and issue tasks to the agents hosted on the node via the UI.

11


-----

Figure 11: Interface of the San Francisco node with task input, resource usage, and agent selector.

**6.4.4** **Task Execution and Result Logging**

Figure 12 shows a completed task handled by the `academic_agent` . The interface logs the complete JSON-RPC request and the corresponding AI-generated response. This validates the agent’s
autonomous reasoning capability and system traceability.
### **7 Conclusions and Future Work**

This work presents AIOS server, a foundational infrastructure for the internet of agentsites, where
each server node can host agents to enable task solving at global scale. One key advantage of AIOS
server lies in its modular, message-oriented architecture, which supports flexible agent orchestration
across heterogeneous environments. The structured communication protocol (MCP + JSON-RPC)
further facilitates interoperability between agents and external services. Evaluation demonstrates
that the AIOS server protocol achieves low latency, high throughput, and efficient decentralized
agent registration under local and cloud-based deployments. These results validate its viability for
real-world applications, particularly in single-agent or loosely coupled multi-agent systems.

Future development will focus on extending AIOS to support multi-agent task orchestration and
improving its robustness in more complex, failure-prone settings, including: 1) *Inter-node commu-*
*nication optimization* : Reducing serialization overhead and supporting asynchronous messaging to
improve throughput under high concurrency; 2) *Adaptive load balancing* : Developing real-time node
profiling and routing strategies based on resource availability and agent capabilities; 3) *Resilience*
*under partial failure* : Introducing fallback mechanisms, timeout-based task migration, and state
checkpointing to improve fault tolerance; 4) *DHT registry validation at scale* : Integrating the DHT +
Gossip registry into a larger distributed deployment with hundreds of nodes and evaluating consistency and convergence under dynamic network conditions; 5) *Security and trust modeling* : Designing
lightweight authentication and authorization schemes for peer-to-peer agent communication.

12


-----

Figure 12: Agent response log showing a completed task with structured output.
### **References**

[1] Chi-Min Chan et al. Chateval: Towards better llm-based evaluators through multi-agent debate.

arXi v preprin t arXiv:2308.07201, 2023.

[2] Weize Chen et al. Agentverse: Facilitating multi-agent collaboration and exploring emergent
behaviors. arXi v preprin t arXiv:2305.12112, 2023.

[3] Weize Chen, Ziming You, Ran Li, Yitong Guan, Chen Qian, Chenyang Zhao, Cheng Yang,
Ruobing Xie, Zhiyuan Liu, and Maosong Sun. Internet of agents: Weaving a web of heterogeneous agents for collaborative intelligence, 2024.

[4] Xiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Sam Stevens, Boshi Wang, Huan Sun, and
Yu Su. Mind2web: Towards a generalist agent for the web. In Advance s i n Neura l Information

Processin g System s (NeurIPS), volume 36, 2024.

[5] Yilun Du et al. Improving factuality and reasoning in language models through multiagent
debate. arXi v preprin t arXiv:2305.14325, 2023.

[6] Yingqiang Ge, Wenyue Hua, Kai Mei, Juntao Tan, Shuyuan Xu, Zelong Li, and Yongfeng
Zhang. Openagi: When llm meets domain experts. Advance s i n Neura l Informatio n Processing
Systems, 36, 2023.

[7] Sirui Hong et al. Metagpt: Meta programming for multi-agent collaborative framework. arXiv

preprin t arXiv:2308.00352, 2023.

[8] Iat Long Iong, Xiao Liu, Yuxuan Chen, Hanyu Lai, Shuntian Yao, Pengbo Shen, Hao Yu, Yuxiao
Dong, and Jie Tang. Openwebagent: An open toolkit to enable web agents on large language
models. In Proceeding s o f th e 62n d Annua l Meetin g o f th e Associatio n fo r Computational
Linguistic s (Volum e 3 : Syste m Demonstrations), pages 72–81, 2024.

13


-----

[9] Guohao Li, Hasan Hammoud, Hani Itani, Dmitrii Khizbullin, and Bernard Ghanem. Camel:
Communicative agents for" mind" exploration of large language model society. Advance s in
Neura l Informatio n Processin g Systems, 36:51991–52008, 2023.

[10] Zelong Li et al. Formal-llm: Integrating formal language and natural language for controllable
llm-based agents. arXi v preprin t arXiv:2402.00798, 2024.

[11] Tian Liang et al. Encouraging divergent thinking in large language models through multi-agent
debate. arXi v preprin t arXiv:2305.19118, 2023.

[12] Kai Mei, Xi Zhu, Wujiang Xu, Wenyue Hua, Mingyu Jin, Zelong Li, Shuyuan Xu, Ruosong Ye,
Yingqiang Ge, and Yongfeng Zhang. Aios: Llm agent operating system, 2024.

[13] Grégoire Mialon et al. Gaia: A benchmark for general ai assistants. arXi v preprint
arXiv:2311.12983, 2023.

[14] Xianghe Pang, Shuo Tang, Rui Ye, Yuxin Xiong, Bolun Zhang, Yanfeng Wang, and Siheng
Chen. Self-alignment of large language models via multi-agent social simulation. In ICLR
202 4 Worksho p o n Larg e Languag e Mode l (LLM ) Agents, 2024.

[15] Chen Qian et al. Communicative agents for software development. arXi v preprint
arXiv:2307.07924, 2023.

[16] Guanzhi Wang et al. Voyager: An open-ended embodied agent with large language models.

arXi v preprin t arXiv:2305.16291, 2023.

[17] Lei Wang, Chen Ma, Xueyang Feng, Zeyu Zhang, Hao Yang, Jingsen Zhang, Zhiyuan Chen,
Jiakai Tang, Xu Chen, Yankai Lin, et al. A survey on large language model based autonomous
agents. Frontier s o f Compute r Science, 18(6):186345, 2024.

[18] Zora Zhiruo Wang, Jiayuan Mao, Daniel Fried, and Graham Neubig. Agent workflow memory.

arXi v preprin t arXiv:2409.07429, 2024.

[19] Qingyun Wu et al. Autogen: Enabling next-gen llm applications via multi-agent conversation
framework. arXi v preprin t arXiv:2308.08155, 2023.

[20] Zhiyong Wu et al. Os-copilot: Towards generalist computer agents with self-improvement.

arXi v preprin t arXiv:2402.07456, 2024.

[21] Wujiang Xu, Zujie Liang, Kai Mei, Hang Gao, Juntao Tan, and Yongfeng Zhang. A-mem:
Agentic memory for llm agents. arXi v preprin t arXiv:2502.12110, 2025.

[22] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao.
React: Synergizing reasoning and acting in language models. arXi v preprin t arXiv:2210.03629,
2022.

[23] Dingyao Yu, Kaitao Song, Peiling Lu, Tianyu He, Xu Tan, Wei Ye, Shikun Zhang, and Jiang
Bian. Musicagent: An ai agent for music understanding and generation with large language
models, 2023.

[24] Hanrong Zhang, Jingyuan Huang, Kai Mei, Yifei Yao, Zhenting Wang, Chenlu Zhan, Hongwei
Wang, and Yongfeng Zhang. Agent security bench (asb): Formalizing and benchmarking attacks
and defenses in llm-based agents. arXi v preprin t arXiv:2410.02644, 2024.

[25] Wangchunshu Zhou, Yuchen Eleanor Jiang, Long Li, Jialong Wu, Tiannan Wang, Shi Qiu,
Jintian Zhang, Jing Chen, Ruipu Wu, Shuai Wang, Shiding Zhu, Jiyu Chen, Wentao Zhang,
Ningyu Zhang, Huajun Chen, Peng Cui, and Mrinmaya Sachan. Agents: An open-source
framework for autonomous language agents, 2023.

14


-----

### **A Human-Agent Communication**

**A.1** **Message Schema Explanation**

The following explains each field of the human-agent communication request:

- `"jsonrpc"` : Protocol version identifier (e.g., "2.0").

- `"id"` : Unique identifier used to match requests and responses.

- `"method"` : Name of the remote method invoked (e.g., `"aios/delegateTask"` ).

- `"params"` : Contains task-specific parameters:

**–** `"sender"` : Entity initiating the request.

**–**
`"recipient"` : Target AI agent receiving the request.

**–**
`"messages"` : User-provided messages forming the input.

**–** `"maxTokens"` : Token limit for the response output.

**A.2** **Example: User Request**



**A.3** **Message Schema Explanation (Response)**

- `"jsonrpc"` : Protocol version.

- `"id"` : Corresponds to the original request ID.

- `"result"` : Contains the response from the agent:

**–** `"sender"` : Responding agent.

**–**
`"recipient"` : Original human user.

**–** `"content"` : Task result or response content.

**–** `"model"` : Language model used to generate response.

**–**
`"stopReason"` : Indicates how response was terminated.

15


-----

**A.4** **Example: AI Agent Response**



16


-----

### **B Agent-Agent Communication**

**B.1** **Message Schema Explanation (Request)**

- `"jsonrpc"` : Protocol version.

- `"id"` : Identifier of the task.

- `"method"` : Operation being requested (e.g., `"aios/delegateTask"` ).

- `"params"` :

**–** `"intent"` : Purpose of the request (e.g., data extraction).

**–** `"sender"` : Requesting agent and role.

**–**
`"recipient"` : Target agent and role.

**–** `"task"` : Task metadata and parameters.

**B.2** **Task Delegation Request**



**B.3** **Message Schema Explanation (Response)**

- `"jsonrpc"` : Protocol version.

- `"id"` : Same ID as the original request.

- `"result"` :

**–** `"sender"` : Agent responding to the task.

**–**
`"recipient"` : Agent that issued the task.

**–** `"content"` : Result of the task, including output.

**–** `"isError"` : Indicates if the task failed.

17


-----

**B.4** **Agent Response**



18


-----

### **C AIOS Node Communication Formats**

**C.1** **AIOS Node Status Report**

**Field Explanation:**

- `"node_id"` : Unique identifier for the node.

- `"node_name"` : System name of the node.

- `"timestamp"` : UTC timestamp of the report.

- `"system_info"` : Hardware and usage statistics.

- `"available_agents"` : List of agents currently deployed on the node.



**C.2** **AIOS Task Assignment Format**

**Field Explanation:**

- `"task_id"` : Task identifier.

- `"assigned_agent"` : Name of the agent responsible for the task.

- `"status"` : Current execution status (e.g., running, completed).




19


-----

### **D Implementation of Distributed Agent Registry Prototype**

This section presents key excerpts from the prototype implementation of AIOS’s decentralized agent
registration and discovery system. The system combines a Kademlia-based Distributed Hash Table
(DHT) for structured key-value storage with a lightweight Gossip protocol for periodic presence
synchronization.

**D.1** **DHT Class for Agent Registration**

This class handles agent metadata registration into the DHT overlay, enabling global discoverability
via unique identifiers. Metadata such as node address and timestamp is encoded before being
distributed.

Listing 1: DHT Agent Registry Class
```
class DHT:
   def __init__(self, ip, port, node_id=None, k=20):
     self.node_id = node_id or NodeID ()
     self.ip = ip
     self.port = port
     self.local_node = Node(self.node_id, ip, port)
     self.routing_table = RoutingTable (self.node_id, k)
     self.data_store = {}
   def register_agent (self, agent_id, metadata):
     key = f "agent :{ agent_id}"
     metadata[ "last_update" ] = time.time ()
     metadata[ "node_id" ] = str (self.node_id)
     metadata[ "node_ip" ] = self.ip
     metadata[ "node_port" ] = self.port
     return self.store(key, metadata)
   def find_agent(self, agent_id):
     key = f "agent :{ agent_id}"
     return self.lookup(key)

```
**D.2** **Gossip Protocol for Presence Synchronization**

This module implements a gossip-based presence tracking protocol. Each node periodically propagates its knowledge of peer agents to a sampled subset of neighbors, balancing coverage and
overhead.

Listing 2: Presence Gossip Protocol
```
class GossipProtocol(asyncio. DatagramProtocol ):
   def __init__(self, node_id, port =8001):
     self.node_id = node_id
     self.port = port
     self.peers = {}
     self.message_cache = {}
     self.callbacks = {}
   def _propagate_message (self, message):
     if message.ttl <= 1:
        return
     new_message = GossipMessage (
        message.sender_id,
        message.message_type,
        message.data,
        message.timestamp,
        message.ttl - 1
     )
     live_peers = [p for p in self.peers.values ()
             if p[ "state" ] != NodeState.DEAD]

```
20


-----

```
     if not live_peers:
        return
     target_count = min ( len (live_peers), max (3, int ( len (live_peers)
        ** 0.5)))
     targets = random.sample(live_peers, target_count)
     for peer in targets:
        addr = (peer[ "ip" ], peer[ "port" ])
        self._send_message (new_message, addr)

```
**D.3** **Agent Directory Service**

This service provides high-level API access for agent capability-based queries. It relies on the
underlying gossip protocol to maintain updated lists of agents and their advertised features.

Listing 3: Agent Presence Directory
```
class GossipAgentDirectoryService :
   def __init__(self, node_id=None, host= "127.0.0.1", port =8001,
          seed_nodes=None):
     self.node_id = node_id or str (uuid.uuid4 ())
     self. presence_service = AgentPresenceService (self.node_id,
       host, port)
     self.seed_nodes = seed_nodes or []
   async def start(self):
     await self. presence_service .start ()
     for node_id, host, port in self.seed_nodes:
        self. presence_service .add_peer(node_id, host, port)
   def register_agent (self, agent_id, capabilities=None):
     return self. presence_service . register_agent (agent_id,
       capabilities)
   def find_agents_by_capability (self, capability):
     agents = self. presence_service . get_agents_by_capability (
       capability)
     return [a.to_dict () for a in agents]

```
**D.4** **Gossip Integrator for AIOS System**

This wrapper class integrates the gossip-based directory service into the broader AIOS runtime. It
ensures that the decentralized components are initialized correctly and available via a consistent
interface.

Listing 4: Gossip Service Integrator
```
class GossipIntegrator :
   def __init__(self, config=None):
     self.config = config or Config ()
     self.service = None
     self.node_id = self.config.get( "p2p.node_id", default=None)
     self.host = self.config.get( "p2p.gossip.host", default= "
       127.0.0.1" )
     self.port = self.config.get( "p2p.gossip.port", default =8001)
   async def initialize(self):
     self.service = GossipAgentDirectoryService (
        node_id=self.node_id,
        host=self.host,
        port=self.port,
        seed_nodes=self.seed_nodes
     )
     await self.service.start ()

```
21


-----

```
def register_agent (self, agent_id, capabilities=None):
   if not self.service:
     return False
   return self.service. register_agent (agent_id, capabilities )

```
22


-----

